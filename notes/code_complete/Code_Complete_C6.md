


## 6.2良好的类接口
### 好的抽象
+ 类的接口应该展现一致的抽象层次；
+ 一定要理解类所实现的抽象是什么；
+ 提供成对的服务； turnOn  turnOff
+ 把不相关的信息转移到其他类中；
+ 让接口可编程，而不是表达语义；
可编程的部分由数据类型和其他属性构成，语义是由‘本接口会被怎样使用’组成。要尽力将语义转化为编程接口的元素，通过编译器的强制校验防止误用；
+ 谨防在修改时破坏接口的抽象；
+ 不要添加和接口抽象不一致的公用成员；
+ 要同时考虑抽象性和内聚性，相辅相成的关系；


### 良好的封装
+ 降低类和成员的可访问性；
+ 不要公开暴露成员数据；
+ 避免把私用的实现细节放入到类的接口中； （可以通过类接口和实现隔离实现）；
+ 不要对类的使用者做出任何假设；
+ 避免使用友元类；
+ 让阅读代码比编写代码更方便；
+ 警惕从语义上破坏封装性；
+ 留意过于紧密的耦合关系；

## 6.3有关设计和实现的问题
### 包含 （“有一个”的关系）
### 继承 (“是一个”的关系)
+ 用public继承来实现“是一个...”的关系；
+ 使用继承要进行详细说明，要么就不要用它；
+ 遵循Liskov（LSP）替换原则；
+ 不要覆盖一个不可覆盖的成员函数；
+ 把公用的接口、数据及操作放到继承树中尽可能高的位置；
+ 只有一个实例的类是值得怀疑的；单例例外
+ 只有一个派生类的基类也是值得怀疑；（不要过分设计）
+ 派生类覆盖了某个子程序，但是其中没有任何操作，这个情况也值得怀疑；通常表明基类的设计有错误；
列：cat类Scratch，不能抓的猫 派生出ScratchlessCat,覆盖Srcatch() 什么都做。应该是cat类包含一个CLaw(爪子)类。
+ 避免让继承体系过深；
+ 尽量使用多态，避免大量的类型检查；
+ 让所有数据都是private（而非protected）,派生类通过访问器函数访问基类属性；
+ 多重继承；

### 成员函数和数据成员
+ 让类中子程序的数量尽可能的少
+ 禁止隐式地产生你不需要的成员函数和运算符；
例：通过把构造函数、赋值运算符或其他成员函数定义为private
+ 减少类所调用的不同子函数的数量（低扇入）；
+ 对其他类的子程序的间接调用要尽可能的少
例：account.ContactPerson().DaytimeContactInfo() 则不合适；
+ 尽量减少类与类之间互相合作的范围：

### 构造函数
+ 尽量在所有的构造函数中初始化所有的额数据成员；
+ 用private构造函数来强制实现单例；
+ 有先采用深层复本，除非论证可行，才采用浅层复本

## 6.4 创建类的原因
+ 为现实世界中的对象建模
+ 为抽象的对象建模； 例：形状(Shape)对象是抽象类，Circle & Sequare都是真实存在的。
+ 降低复杂度；
+ 隔离复杂度
+ 隐藏实现细节；
+ 限制变动的影响范围；
+ 隐藏全局数据；
+ 让参数传递更顺畅；
+ 建立中心控制点；
+ 让代码更易于重用；
+ 为程序族做准备；
+ 把相关操作包装到一起；
+ 实现某种特定的重构；

### 应当避免的类
+ 避免创建万能类
+ 消除无关紧要的类；
+ 避免用动作命名的类；
